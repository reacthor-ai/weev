import type { HttpContext } from "@adonisjs/core/http";
import UnAuthorizedException, { UnAuthorizedErrorCodes } from "#exceptions/un_authorized_exception";
import redis from "@adonisjs/redis/services/main";
import { CreateShopeeTokenValidatorType, inputQueryShopeeApiPath } from "#validators/shopee_token";
import RedisException, { RedisErrorCodes } from "#exceptions/redis_exception";
import * as crypto from "crypto";
import { NextFn } from "@adonisjs/core/types/http";
import * as process from "process";

export default class WeevIntegrationsTokenMiddleware {
  async handle(ctx: HttpContext, next: NextFn) {
    const token = ctx.request.headers()["authorization"];

    if (!token) {
      return new UnAuthorizedException("The token does not exist. Did you forget to add it in your headers?", {
        code: UnAuthorizedErrorCodes.TOKEN_NOT_FOUND,
        status: 401
      });
    }

    try {
      const sanitizedToken = token.replace("Bearer ", "");
      const [, userId] = sanitizedToken.split("_");

      const payload = await redis.get(`weev-token-shopee-${userId}`);

      if (!payload) return next();

      if (payload) {
        const weevInfo: CreateShopeeTokenValidatorType = JSON.parse(payload);

        const data = ctx.request.all();
        const { api_path } = await inputQueryShopeeApiPath.validate(data);

        const genTokenRes = this._generateSignToken(api_path);

        const value = {
          ...weevInfo,
          ...genTokenRes
        };

        ((ctx as unknown as { info: typeof value }).info) = {
          ...value
        };
        return next();
      }

    } catch (error) {
      throw new RedisException(`${error}`, {
        status: 500,
        code: RedisErrorCodes.REDIS_GET_ERROR
      });
    }
  }

  /**
   * PRIVATE Method _generateSignToken
   * this is needs to be signed for every execution.
   * Signature generated by partner_id, api path, timestamp and partner_key via
   * HMAC-SHA256 hashing algorithm.
   * More details: https://open.shopee.com/documents?module=87&type=2&id=58&version=2
   */
  private _generateSignToken(api_path: string) {
    const partner_id = process.env.PARTNER_ID;
    const partner_key = process.env.PARTNER_KEY;
    const timestamp = Math.floor(new Date().getTime() / 1000).toString();

    if (!partner_id || !partner_key) {
      throw new Error("Partner ID or Partner Key is missing");
    }

    // Create the base string for HMAC-SHA256 hashing
    const baseString = `${partner_id}${api_path}${timestamp}`;

    // Generate the HMAC-SHA256 signature
    const sign = crypto.createHmac("sha256", partner_key)
      .update(baseString)
      .digest("hex");

    return {
      timestamp: parseInt(timestamp, 10),
      partner_id: parseInt(partner_id, 10),
      sign
    };
  }
}
